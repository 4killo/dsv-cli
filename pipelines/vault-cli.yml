---
parameters:
  - name: clean
    displayName: Checkout clean
    type: boolean
    default: false
    values:
      - false
      - true

  # Bypass scans & tests on repeated runs that have already passed these, helping troubleshooting pipeline issues on a release more quickly
  - name: yolo
    displayName: you only live once
    type: boolean
    default: false
    values:
      - false
      - true

variables:
  - group: 'CLI_integration_test'
  - group: 'CLi-pipeline-variables'
  - group: 'CLI End-to-End tests'
  - name: GO_VERSION
    value: 1.18.4
trigger:
  branches:
    include:
      - master
  paths:
    exclude:
      - .devcontainer/*
      - .github/*
      - '*.md'
      - '**/*.md'

schedules:
  - cron: '0 6 * * 1-5'
    displayName: 'Mon through Fri at 6:00'
    branches:
      include:
        - master

jobs:
  - job: Build_All_Platforms
    pool:
      name: DSV-Golang-AWS

    steps:
      - checkout: self
        clean: ${{ parameters.clean }}

      - task: thycotic-software.thycotic-dsv-task.thycotic-dsv-build-release-task.ThycoticDSV@0
        displayName: 'Retrieve ado/cli from Thycotic DevOps Secrets Vault'
        inputs:
          ServerUrl: '$(ServerUrl)'
          ClientId: '$(ClientId)'
          ClientSecret: '$(ClientSecret)'
          SecretPath: ado/cli

      - task: GoTool@0
        displayName: 'Use Go $(GO_VERSION)'
        inputs:
          version: $(GO_VERSION)

      - task: WhiteSource@21
        condition: ne(${{ parameters.yolo }}, 'true')
        inputs:
          cwd: '$(System.DefaultWorkingDirectory)'
          scanReportTimeout: '3'

      - bash: |
          go mod download
        displayName: 'Download dependencies'

      - bash: |
          # echo "[---] Install editor (nano)"
          # sudo apt-get install nano
          echo "[---] Install hansboder/gocovmerge"
          go install -v github.com/hansboder/gocovmerge@latest
          echo "[---] Finished."
        displayName: 'Install tools'
        condition: ne(${{ parameters.yolo }}, 'true')

      - bash: |
          echo "[---] git describe: $(git describe --always --dirty --tags)"
          go test -v -p 1 -covermode=count -coverprofile=./coverage.out ./... | tee test.out
          rm -f cli-config/.thy.yml
          echo "[---] Merging coverage."
          ~/go/bin/gocovmerge -dir coverage -pattern "\.out" > ./coverage-integration.out
          rm -rf coverage
          echo "[---] Finished."
        displayName: 'Run tests'
        condition: ne(${{ parameters.yolo }}, 'true')

      - bash: |
          cat test.out | ~/go/bin/go-junit-report -set-exit-code > ./report.xml
        displayName: 'Generate report'
        condition: ne(${{ parameters.yolo }}, 'true')

      - bash: |
          echo "[---] git describe: $(git describe --always --dirty --tags)"

          echo "[---] Starting End-to-End testing."
          make e2e-test | tee test-e2e.out

          echo "[---] Merging E2E coverage results into one file."
          ~/go/bin/gocovmerge -dir ./tests/e2e/coverage -pattern "\.out" > ./coverage-e2e.out
          rm -rf ./tests/e2e/coverage

          echo "[---] Finished."
        condition: and(always(), ne(${{ parameters.yolo }}, 'true'))
        displayName: '[E2E] Run tests'

      - bash: |
          cat test-e2e.out | ~/go/bin/go-junit-report -set-exit-code > ./report-e2e.xml
        displayName: '[E2E] Generate report'
        condition: ne(${{ parameters.yolo }}, 'true')

      - bash: |
          echo "[---] Merging coverage.out, coverage-e2e.out and coverage-integration.out files."
          ~/go/bin/gocovmerge coverage.out coverage-e2e.out coverage-integration.out > ./coverage-all.out

          echo "[---] Converting coverage-all.out to codecoverage.xml file."
          ~/go/bin/gocov convert coverage-all.out | ~/go/bin/gocov-xml > ./codecoverage.xml

          echo "[---] Finished."
        displayName: 'Prepare coverage'
        condition: ne(${{ parameters.yolo }}, 'true')

      - task: PublishTestResults@2
        displayName: 'Publish Test Results'
        inputs:
          testResultsFiles: |
            **/report.xml
            **/report-e2e.xml
          mergeTestResults: true
          failTaskOnFailedTests: true
          testRunTitle: 'CLI Tests'
        condition: and(succeededOrFailed(), ne(${{ parameters.yolo }}, 'true'))

      - task: PublishCodeCoverageResults@1
        displayName: 'Publish Code Coverage'
        inputs:
          codeCoverageTool: Cobertura
          summaryFileLocation: '$(System.DefaultWorkingDirectory)/codecoverage.xml'
          failIfCoverageEmpty: true
        condition: and(succeededOrFailed(), ne(${{ parameters.yolo }}, 'true'))

      - bash: |
          echo "[---] git describe: $(git describe --always --dirty --tags)"
          # clean build directory
          make clean build-release-all create-checksum capture-latest-version

          version=$(git describe --always --dirty --tags)
          echo "##vso[task.setvariable variable=CLI_Version;]$version"

          mkdir $(Build.ArtifactStagingDirectory)/version
          mv bin/cli-version.json $(Build.ArtifactStagingDirectory)/version
        displayName: 'Make - Release Builds'

      - task: CopyFiles@2
        displayName: 'Copy Unsigned Builds To Staging Directory'
        inputs:
          SourceFolder: '$(System.DefaultWorkingDirectory)/bin/'
          TargetFolder: '$(Build.ArtifactStagingDirectory)/bin/'
          CleanTargetFolder: true
          OverWrite: true

      - task: PublishBuildArtifacts@1
        displayName: 'Build Artifact: Latest version file'
        inputs:
          PathtoPublish: '$(Build.ArtifactStagingDirectory)/version/cli-version.json'
          ArtifactName: 'cli-latest-version'

      - task: PublishPipelineArtifact@1
        displayName: 'Pipeline Artifact: Unsigned Builds'
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/bin'
          artifact: 'ReleaseBuilds-Unsigned'

      - task: Bash@3
        displayName: 'Public GitHub Sync'
        inputs:
          filePath: pipelines/scripts/github_sync.sh
        env:
          SourceVersion: $(Build.SourceVersion)
          githubPat: $(githubPat)
        condition: and(succeeded(), or(startsWith(variables['Build.SourceBranch'], 'refs/heads/release/'), startsWith(variables['Build.SourceBranch'], 'refs/tags/')))

  - job: Sign_Windows_Binary
    dependsOn: Build_All_Platforms
    pool:
      vmImage: windows-latest
      # name: Bambe-Windows
    steps:
      - checkout: self
        clean: ${{ parameters.clean }}

      - task: GoTool@0
        displayName: 'Use Go $(GO_VERSION)'
        inputs:
          version: $(GO_VERSION)

      - pwsh: |
          Write-Host "[---] Deleting test cache."
          &go clean -testcache
          Write-Host "[---] Starting End-to-End testing."
          &go test -v -tags=endtoend ./tests/e2e
          Write-Host "[---] Finished."
          Write-Host "[---] Note: Results are not published."
        displayName: '[E2E] Run tests'
        condition: ne(${{ parameters.yolo }}, 'true')

      - task: thycotic-software.thycotic-dsv-task.thycotic-dsv-build-release-task.ThycoticDSV@0
        displayName: 'Retrieve ado/cli from Thycotic DevOps Secrets Vault'
        inputs:
          ServerUrl: '$(ServerUrl)'
          ClientId: '$(ClientId)'
          ClientSecret: '$(ClientSecret)'
          SecretPath: 'ado/cli '

      - pwsh: |
          # Clean out old builds from cli dir
          $CLIDirectory = Join-Path $ENV:SYSTEM_DEFAULTWORKINGDIRECTORY 'cli'
          $CoverageDirectory = Join-Path $ENV:SYSTEM_DEFAULTWORKINGDIRECTORY 'coverage'

          Remove-Item $CLIDirectory -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item $CoverageDirectory -Recurse -Force -ErrorAction SilentlyContinue
        workingDirectory: '$(Pipeline.Workspace)'
        displayName: 'Clear Pipeline Directory'

      - task: DownloadPipelineArtifact@2
        displayName: 'Download Unsigned Builds'
        inputs:
          artifactName: 'ReleaseBuilds-Unsigned'
          targetPath: '$(Pipeline.Workspace)/cli'

      - pwsh: |
          $version = &git describe --always --dirty --tags
          Write-Host "##vso[task.setvariable variable=cliversion]$version"
        workingDirectory: '$(System.DefaultWorkingDirectory)'
        displayName: 'Get Version'

      - pwsh: |
          Remove-Item (Join-Path '$(cliversion)' '$(constants.cliname)-darwin-arm64') -ErrorAction SilentlyContinue
          Remove-Item (Join-Path '$(cliversion)' '$(constants.cliname)-darwin-arm64-sha256.txt') -ErrorAction SilentlyContinue
          Remove-Item (Join-Path '$(cliversion)' '$(constants.cliname)-darwin-x64') -ErrorAction SilentlyContinue
          Remove-Item (Join-Path '$(cliversion)' '$(constants.cliname)-darwin-x64-sha256.txt') -ErrorAction SilentlyContinue
          Write-Host (Get-ChildItem '$(cliversion)' -ErrorAction SilentlyContinue | Format-Table -Autosize -Wrap | Out-String)
        workingDirectory: '$(Pipeline.Workspace)/cli'
        displayName: 'Clear Unused Files'

      - pwsh: |
          Write-Host $(cliversion)
          Get-ChildItem -Recurse

          $X64Version = Resolve-Path (Join-Path $(cliversion) $(constants.cliname)-win-x64.exe)
          $X86Version = Resolve-Path (Join-Path $(cliversion) $(constants.cliname)-win-x86.exe)

          try {
            Test-Path -LiteralPath $X86Version -PathType Leaf && Write-Host "âœ… $X86Version verified to exist"

            @($X64Version, $X86Version)  | ForEach-Object {
              [string]$binary = $_
              Test-Path -LiteralPath $binary -PathType Leaf && Write-Host "âœ… $binary verified to exist"

              $command = 'signtool sign /tr "http://timestamp.digicert.com" /td sha256 /fd sha256 /sha1 668feb4178afea4d3c4ae833459b09c2bcf6b64e "$binary"'
              Write-Host "ðŸ‘‰ running: $command"
              Invoke-Expression $command
            }
            Write-Host "ðŸŽ‰ these binaries were signed. celebrate"
          }
          catch {
            Write-Error "problem signing binaries"
            throw
          }

        workingDirectory: '$(Pipeline.Workspace)/cli'
        displayName: 'Sign Windows Executable'
        env:
          CLI_Version: $(CLI_Version)

      - pwsh: |
          $X64Version = Join-Path $(cliversion) $(constants.cliname)-win-x64.exe
          $X86Version = Join-Path $(cliversion) $(constants.cliname)-win-x86.exe

          Get-FileHash $X64Version -Algorithm SHA256 | Select -expand Hash | Out-File "$X64Version-sha256.txt"
          Get-FileHash $X86Version -Algorithm SHA256 | Select -expand Hash | Out-File "$X86Version-sha256.txt"
        workingDirectory: '$(Pipeline.Workspace)/cli'
        displayName: 'Regenerate Windows Hash'

      - task: PublishBuildArtifacts@1
        displayName: 'Build Artifact: ReleaseBuilds'
        inputs:
          PathtoPublish: '$(Pipeline.Workspace)/cli'
          ArtifactName: ReleaseBuilds

  - job: Sign_Mac_OS_Binary
    dependsOn: Build_All_Platforms
    pool:
      vmImage: macOS-11
      name: Azure Pipelines
      demands: xcode

    steps:
      - checkout: self
        clean: ${{ parameters.clean }}

      - task: DownloadPipelineArtifact@2
        displayName: 'Download Unsigned Builds'
        inputs:
          artifactName: 'ReleaseBuilds-Unsigned'
          targetPath: '$(Pipeline.Workspace)/cli'

      - bash: |
          version=$(git describe --always --dirty --tags)
          echo "##vso[task.setvariable variable=cliversion]$version"
        workingDirectory: '$(System.DefaultWorkingDirectory)'
        displayName: 'Get version'

      - task: InstallAppleCertificate@2
        displayName: 'Install Certificate to keychain'
        inputs:
          certSecureFile: '$(certSecureFile)'
          certPwd: '$(cert.password)'
          setUpPartitionIdACLForPrivateKey: false

      - bash: |
          echo $(cliversion)
          cd $(cliversion)
          ls
          ls ~/Library/Keychains

          #Clear unused files
          rm ./$(constants.cliname)-linux-x64
          rm ./$(constants.cliname)-linux-x64-sha256.txt
          rm ./$(constants.cliname)-linux-x86
          rm ./$(constants.cliname)-linux-x86-sha256.txt
          rm ./$(constants.cliname)-win-x64.exe
          rm ./$(constants.cliname)-win-x64.exe-sha256.txt
          rm ./$(constants.cliname)-win-x86.exe
          rm ./$(constants.cliname)-win-x86.exe-sha256.txt
          ls

          echo "[---] Signing x64 binary."
          codesign -s 'Thycotic Software' ./$(constants.cliname)-darwin-x64
          echo "[---] Signing arm64 binary."
          codesign -s 'Thycotic Software' ./$(constants.cliname)-darwin-arm64
          echo "[---] Finished."
        workingDirectory: '$(Pipeline.Workspace)/cli'
        displayName: 'Sign macOS binaries'

      - bash: |
          brew install coreutils
          sudo ln -s /usr/local/bin/gsha256sum /usr/local/bin/sha256sum
          cd $(cliversion)
          sha256sum ./$(constants.cliname)-darwin-x64 > ./$(constants.cliname)-darwin-x64-sha256.txt
          sha256sum ./$(constants.cliname)-darwin-arm64 > ./$(constants.cliname)-darwin-arm64-sha256.txt
        workingDirectory: '$(Pipeline.Workspace)/cli'
        displayName: 'Regenerate macOS Hash'

      - task: PublishBuildArtifacts@1
        displayName: 'Build Artifact: ReleaseBuilds'
        inputs:
          PathtoPublish: '$(Pipeline.Workspace)/cli'
          ArtifactName: ReleaseBuilds
